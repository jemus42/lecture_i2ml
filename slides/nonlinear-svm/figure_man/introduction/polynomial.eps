%!PS-Adobe-2.0
%%Creator: Sketch
%%Title: figures/introduction/polynomial.sketch
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: -30.000000 -10.000000 230.000000 180.000000
%%EndComments

gsave
1 setlinewidth [] 0 setdash 0 setgray
(Helvetica) findfont
dup length dict begin
	{ 1 index /FID ne { def } { pop pop } ifelse } forall
	/Encoding ISOLatin1Encoding def
	currentdict
end
(Latin1) exch definefont pop
(Latin1) findfont 6.000000 scalefont setfont
-30.000000 -10.000000 260.000000 190.000000 rectclip
100 dict begin
/none null def
/fontface (Helvetica) def
/fontsize 6.000000 def
{

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% sketch library
%

/ERROR_printobject { dup type /arraytype eq { newpath 2 index 2 index 4 sub moveto 2 index 50 add 2 index 4 sub lineto stroke newpath 2 index 2 index moveto ([) show dup length (     ) cvs show (]) show stroke 3 -1 roll 30 add 3 -1 roll 14 add 3 -1 roll { ERROR_printobject } forall exch 30 sub exch newpath 1 index 1 index 4 sub moveto 1 index 50 add 1 index 4 sub lineto stroke } { dup type /stringtype eq { newpath 2 index 2 index moveto (\() show show (\)) show stroke 14 add } { dup type /nulltype eq { newpath 2 index 2 index moveto pop (/none) show stroke 14 add } { dup type /nametype eq { newpath 2 index 2 index moveto (/) show 256 string cvs show stroke 14 add } { newpath 2 index 2 index moveto 256 string cvs show stroke 14 add } ifelse } ifelse } ifelse } ifelse } bind def
/ERROR { initgraphics /Helvetica findfont 12 scalefont setfont 1 setlinewidth [ ] 0 setdash 0.5 0.0 0.0 setrgbcolor newpath 0 0 moveto 10000 0 lineto 10000 10000 lineto 0 10000 lineto closepath fill 1.0 setgray newpath 0 30 moveto 500 30 lineto 500 60 lineto 0 60 lineto closepath fill 10 10 moveto ([SketchLib] An error or debug condition occured) show 0.0 setgray 10 40 moveto show 1.0 setgray 10 70 2 1 count 3 sub { index ERROR_printobject } for stop } bind def
/DEBUG { (DEBUG) ERROR } bind def
/IsBool { type /booleantype eq } bind def
/IsNone { none eq } bind def
/IsInt { type /integertype eq } bind def
/IsReal { type /realtype eq } bind def
/IsNumber { dup type /integertype eq exch type /realtype eq or } bind def
/IsString { type /stringtype eq } bind def
/IsName { type /nametype eq } bind def
/IsArray { type /arraytype eq } bind def
/AssertNone { IsNone not { (ASSERTION FAILED: none expected) ERROR } if } bind def
/AssertBoolean { IsBool not { (ASSERTION FAILED: boolean expected) ERROR } if } bind def
/AssertInt { IsInt not { (ASSERTION FAILED: integer expected) ERROR } if } bind def
/AssertReal { IsReal not { (ASSERTION FAILED: real expected) ERROR } if } bind def
/AssertNumber { IsNumber not { (ASSERTION FAILED: number expected) ERROR } if } bind def
/AssertString { IsString not { (ASSERTION FAILED: string expected) ERROR } if } bind def
/AssertName { IsName not { (ASSERTION FAILED: name expected) ERROR } if } bind def
/AssertArray { IsArray not { (ASSERTION FAILED: array expected) ERROR } if } bind def
/AssertArrayLength { exch dup AssertArray length ne { (ASSERTION FAILED: wrong array size) ERROR } if } bind def
/AssertArrayIndex { dup AssertInt exch dup AssertArray length ge { (ASSERTION FAILED: invalid index into array) ERROR } if } bind def
/ArrayElement { dup AssertInt dup 0 lt { ([ArrayElement] index too small) ERROR } if 1 index AssertArray 1 index length 1 index le { ([ArrayElement] index out of range) ERROR } if dup 0 lt { ([ArrayElement] index out of range) ERROR } if get } bind def
/SetArrayElement { 2 index AssertArray 1 index AssertInt 2 index length 2 index le { ([SetArrayElement] index too large) ERROR } if 1 index 0 lt { ([SetArrayElement] index out of range) ERROR } if 3 -1 roll aload length dup 3 add -2 roll 2 index 2 index sub 3 add -1 roll pop 2 index 2 index sub 2 add 1 roll pop array astore } bind def
/ConcatArrays { dup AssertArray 1 index AssertArray exch aload length dup 2 add -1 roll aload length dup 2 add -1 roll add array astore } bind def
/ConcatStrings { dup IsString not { 50 string cvs } if 1 index IsString not { exch 50 string cvs exch } if exch dup length 2 index length add string dup dup 4 2 roll copy length 4 -1 roll putinterval } bind def
/Execute { dup AssertArray exch dup AssertName 256 string cvs exch aload length dup 1 add index (__nargs) exch ConcatStrings cvn dup where exch pop not { (Call to invalid function name) ERROR } if load 1 index ne { (Number of arguments for call does not match) ERROR } if 1 add -1 roll cvn cvx exec } bind def
/PopN { -1 1 { pop pop } for } bind def
/UnitVector2d { dup dup mul 2 index dup mul add cvr sqrt 2 index 1 index div 4 1 roll div exch pop } bind def
/CalcPos { 3 1 roll UnitVector2d 4 index 3 index 3 index mul add 4 index 4 index 3 index mul add 7 2 roll 5 PopN } bind def
/ArrowHeadFilled { 3 index dup mul 3 index dup mul add cvr sqrt dup 0 eq { 7 PopN } { 5 -2 roll 2 index div 3 1 roll exch div exch 5 index 4 index 3 index mul sub 5 index 5 index 3 index mul sub newpath 8 -2 roll moveto 1 index 5 index 0.5 mul 4 index mul sub 1 index 6 index 0.5 mul 6 index mul add lineto 1 index 5 index 0.5 mul 4 index mul add 1 index 6 index 0.5 mul 6 index mul sub lineto closepath fill 6 PopN } ifelse } bind def
/SetCol { dup IsNumber { setgray } { dup 3 AssertArrayLength aload pop setrgbcolor } ifelse } bind def
/SetFontFaceAndSize { dup IsNone { pop AssertNone fontface findfont dup length dict begin { 1 index /FID ne { def } { pop pop } ifelse } forall /Encoding ISOLatin1Encoding def currentdict end (Latin1) exch definefont pop (Latin1) findfont fontsize scalefont setfont } { 1 index AssertString dup AssertNumber exch findfont dup length dict begin { 1 index /FID ne { def } { pop pop } ifelse } forall /Encoding ISOLatin1Encoding def currentdict end (Latin1) exch definefont pop (Latin1) findfont exch scalefont setfont } ifelse } bind def
/SetLineStyle { SetCol dup AssertNumber setlinewidth dup IsString { dup (solid) eq { [ ] 0 setdash } { dup (dashed) eq { [3 2] 0 setdash } { dup (dotted) eq { [1 1] 0 setdash } { ([SetStyle] unknown style) ERROR } ifelse } ifelse } ifelse } { dup AssertArray dup length 2 mod 0 ne { ([SetStyle] dash-list must have an even number of entries) ERROR } if 0 setdash } ifelse pop } bind def
/CreatePoly3 { aload pop 3 index 2.0 mul 3 index -2.0 mul add 2 index add 1 index add 4 index -3.0 mul 4 index 3.0 mul add 3 index -2.0 mul add 2 index sub 6 2 roll pop cvr exch pop exch cvr 4 array astore } bind def
/EvalPoly3 { exch aload 5 1 roll 6 -1 roll dup 4 -1 roll mul 3 -1 roll add 1 index dup mul dup 5 -1 roll mul 3 -1 roll add 3 1 roll mul 3 -1 roll mul add } bind def
/InterpolateCurveSegment { 2 index 1 index EvalPoly3 exch pop exch 2 index exch EvalPoly3 exch pop 2 array astore } bind def
/RefineCurve { 3 index 3 index 2 index InterpolateCurveSegment 3 1 roll pop pop 4 index 4 index 4 index InterpolateCurveSegment 3 1 roll pop pop aload aload pop lineto 3 -1 roll aload aload pop 10 2 roll 3 -1 roll sub dup mul 3 1 roll sub dup mul add sqrt dup 2 gt exch currentlinewidth 1.0 add gt or { 4 2 roll 3 index 4 index 4 index add 2.0 div RefineCurve 3 index 3 index add 2.0 div 3 index RefineCurve 4 2 roll } if pop pop 4 2 roll lineto } bind def
/StartPathCurve { 0.0 InterpolateCurveSegment aload pop moveto } bind def
/AddPathCurve { 0.0 1.0 RefineCurve } bind def
/InterpolatePCurve { dup AssertNumber 1 index dup AssertName [ 3 -1 roll ] Execute dup 2 AssertArrayLength } bind def
/RefinePCurve { 3 -1 roll 2 index InterpolatePCurve aload pop 2 copy lineto 3 -1 roll 3 index InterpolatePCurve aload pop 2 copy 6 -1 roll sub dup mul exch 6 -1 roll sub dup mul add sqrt dup 2 gt exch currentlinewidth 1.0 add gt or 4 index 6 index sub 0.01 gt or 4 index 6 index sub 0.000001 gt and { 3 -1 roll 4 index 5 index 5 index add 2.0 div RefinePCurve 4 index 4 index add 2.0 div 4 index RefinePCurve 3 1 roll } if lineto exch pop exch pop } bind def
/StartPathPCurve { 0.0 InterpolatePCurve aload pop moveto } bind def
/AddPathPCurve { RefinePCurve } bind def
/PCurve { exch StartPathPCurve 0.0 1.0 AddPathPCurve pop { closepath } if } bind def
/CurveWithTangents { newpath { dup length dup 1 sub 0 exch 1 exch { dup 1 add 2 index mod 3 index 2 index ArrayElement 0 ArrayElement 4 index 2 index ArrayElement 0 ArrayElement 5 index 4 index ArrayElement 2 ArrayElement 6 index 4 index ArrayElement 2 ArrayElement 4 array astore CreatePoly3 4 index 3 index ArrayElement 1 ArrayElement 5 index 3 index ArrayElement 1 ArrayElement 6 index 5 index ArrayElement 3 ArrayElement 7 index 5 index ArrayElement 3 ArrayElement 4 array astore CreatePoly3 4 -1 roll pop 3 -1 roll 1 eq { StartPathCurve } if AddPathCurve pop pop } for pop pop closepath } { dup length dup 2 sub 0 exch 1 exch { dup 1 add 2 index mod 3 index 2 index ArrayElement 0 ArrayElement 4 index 2 index ArrayElement 0 ArrayElement 5 index 4 index ArrayElement 2 ArrayElement 6 index 4 index ArrayElement 2 ArrayElement 4 array astore CreatePoly3 4 index 3 index ArrayElement 1 ArrayElement 5 index 3 index ArrayElement 1 ArrayElement 6 index 5 index ArrayElement 3 ArrayElement 7 index 5 index ArrayElement 3 ArrayElement 4 array astore CreatePoly3 4 -1 roll pop 3 -1 roll 1 eq { StartPathCurve } if AddPathCurve pop pop } for pop pop } ifelse } bind def
/CreateCurve { { dup length dup 1 sub -1 0 { 2 index 1 index 3 index add 1 sub 3 index mod ArrayElement aload pop 4 index 3 index 5 index mod ArrayElement aload pop 6 index 5 index 1 add 7 index mod ArrayElement aload pop exch 6 -1 roll sub -0.5 mul exch 5 -1 roll sub -0.5 mul 4 array astore 4 1 roll pop } for exch pop array astore true CurveWithTangents } { dup length 0 2 index 1 index 3 index mod ArrayElement aload pop 2 copy 6 index 5 index 1 add 7 index mod ArrayElement aload pop exch 6 -1 roll sub exch 5 -1 roll sub 4 array astore 4 1 roll pop dup 2 sub 1 exch 1 exch { 2 index 1 index 3 index add 1 sub 3 index mod ArrayElement aload pop 4 index 3 index 5 index mod ArrayElement aload pop 6 index 5 index 1 add 7 index mod ArrayElement aload pop exch 6 -1 roll sub 0.5 mul exch 5 -1 roll sub 0.5 mul 4 array astore 4 1 roll pop } for dup 1 sub 2 index 1 index 3 index add 1 sub 3 index mod ArrayElement aload pop 4 index 3 index 5 index mod ArrayElement aload pop 2 copy exch 6 -1 roll sub exch 5 -1 roll sub 4 array astore 4 1 roll pop exch pop array astore false CurveWithTangents } ifelse } bind def
/CreateLineSegments { dup 0 ArrayElement aload pop moveto dup length 1 exch 1 exch 1 sub { 1 index exch ArrayElement aload pop lineto } for pop } bind def
/coord_xunit 1.0 def
/coord_yunit 1.0 def
/coord_xoffset 0.0 def
/coord_yoffset 0.0 def
/functiontoplot none def
/plotfunctionfrom 0.0 def
/plotfunctionto 1.0 def
/TransformFCoords { coord_yunit mul coord_yoffset add exch coord_xunit mul coord_xoffset add exch } bind def
/fplot { plotfunctionto plotfunctionfrom sub mul plotfunctionfrom add [ exch dup coord_xunit mul coord_xoffset add exch functiontoplot exch [ exch ] Execute coord_yunit mul coord_yoffset add ] } bind def
/__nargsfplot 1 def
/OperatorPlus { dup IsString { ConcatStrings } { 1 index IsString { ConcatStrings } { dup IsNumber { 1 index IsNumber not { ([OperatorPlus] argument types do not agree) ERROR } if add } { 1 index type 1 index type ne { ([OperatorPlus] argument types do not agree) ERROR } if dup IsArray { 1 index length 1 index length ne { ([OperatorPlus] array operands must have same length) ERROR } if dup length dup 1 1 3 -1 roll { 1 sub 3 index 1 index ArrayElement exch 3 index exch ArrayElement add 4 1 roll } for exch pop exch pop array astore } { ([OperatorPlus] argument type not supported) ERROR } ifelse } ifelse } ifelse } ifelse } bind def
/OperatorMinus { dup IsNumber { 1 index IsNumber not { ([OperatorMinus] argument types do not agree) ERROR } if sub } { 1 index type 1 index type ne { ([OperatorMinus] argument types do not agree) ERROR } if dup IsArray { 1 index length 1 index length ne { ([OperatorMinus] array operands must have same length) ERROR } if dup length dup 1 1 3 -1 roll { 1 sub 3 index 1 index ArrayElement exch 3 index exch ArrayElement sub 4 1 roll } for exch pop exch pop array astore } { ([OperatorMinus] argument type not supported) ERROR } ifelse } ifelse } bind def
/OperatorNegate { dup IsNumber { neg } { dup IsArray { 0 1 2 index length 1 sub { 1 index exch ArrayElement neg exch } for length array astore } { ([OperatorNegate] argument type not supported) ERROR } ifelse } ifelse } bind def
/OperatorTimes { 1 index IsArray { dup 2 index length AssertArrayLength dup length dup 1 1 3 -1 roll { 1 sub 3 index 1 index ArrayElement exch 3 index exch ArrayElement mul 4 1 roll } for exch pop exch pop -1 2 { pop add } for } { 1 index AssertNumber dup IsArray { dup length dup 1 1 3 -1 roll { 1 sub 2 index exch ArrayElement 3 index mul 4 1 roll } for exch pop exch pop array astore } { dup AssertNumber mul } ifelse } ifelse } bind def
/OperatorDivide { dup AssertNumber dup 0.0 eq { ([OperatorDivide] division by zero) ERROR } if 1 index IsArray { 1 index length dup 1 1 3 -1 roll { 1 sub 3 index exch ArrayElement 2 index div 4 1 roll } for exch pop exch pop array astore } { 1 index AssertNumber div } ifelse } bind def
/OperatorModulo { dup AssertNumber cvi exch dup AssertNumber cvi exch dup 0 eq { ([OperatorModulo] division by zero) ERROR } if mod } bind def
/OperatorPower { 1 index AssertNumber 1 index AssertNumber exp } bind def
/OperatorAnd { 1 index AssertBoolean 1 index AssertBoolean and } bind def
/OperatorOr { 1 index AssertBoolean 1 index AssertBoolean or } bind def
/OperatorNot { dup AssertBoolean not } bind def
/OperatorEqual { dup IsNumber { 1 index IsNumber not { pop pop false } { eq } ifelse } { dup IsArray { 1 index IsArray not { pop pop false } if 1 index length 1 index length eq { dup length dup 1 1 3 -1 roll { 1 sub 3 index 1 index ArrayElement exch 3 index exch ArrayElement eq 4 1 roll } for exch pop exch pop -1 2 { pop and } for } { pop pop false } ifelse } { 1 index type 1 index type ne { pop pop false } { eq } ifelse } ifelse } ifelse } bind def
/OperatorNotEqual { OperatorEqual not } bind def
/OperatorLess { 1 index AssertNumber 1 index AssertNumber lt } bind def
/OperatorLessEqual { 1 index AssertNumber 1 index AssertNumber le } bind def
/OperatorGreater { 1 index AssertNumber 1 index AssertNumber gt } bind def
/OperatorGreaterEqual { 1 index AssertNumber 1 index AssertNumber ge } bind def
/_e 2.71828182845905 def
/_pi 3.14159265358979 def
/pi180 _pi 180.0 div def
/_length { dup AssertArray length } bind def
/__nargs_length 1 def
/_Array { dup AssertInt [ 3 1 roll 2 1 3 -1 roll { pop dup } for ] } bind def
/__nargs_Array 2 def
/_Concat { ConcatArrays } bind def
/__nargs_Concat 2 def
/_abs { dup AssertNumber abs } bind def
/__nargs_abs 1 def
/_sqrt { dup AssertNumber sqrt } bind def
/__nargs_sqrt 1 def
/_log { dup AssertNumber ln } bind def
/__nargs_log 1 def
/_exp { dup AssertNumber _e exch exp } bind def
/__nargs_exp 1 def
/_sin { dup AssertNumber pi180 div sin } bind def
/__nargs_sin 1 def
/_cos { dup AssertNumber pi180 div cos } bind def
/__nargs_cos 1 def
/_tan { dup AssertNumber pi180 div dup sin exch cos div } bind def
/__nargs_tan 1 def
/_atan { dup AssertNumber 1.0 atan dup 180 ge { 360.0 sub } if pi180 mul } bind def
/__nargs_atan 1 def
/_atan2 { 2 copy AssertNumber AssertNumber atan dup 180 ge { 360.0 sub } if pi180 mul } bind def
/__nargs_atan2 2 def
/_sinh { dup AssertNumber dup _e exch exp exch neg _e exch exp sub 2.0 div } bind def
/__nargs_sinh 1 def
/_cosh { dup AssertNumber dup _e exch exp exch neg _e exch exp add 2.0 div } bind def
/__nargs_cosh 1 def
/_tanh { dup AssertNumber dup _sinh exch _cosh div } bind def
/__nargs_tanh 1 def
/_floor { dup AssertNumber floor } bind def
/__nargs_floor 1 def
/_ceil { dup AssertNumber ceiling } bind def
/__nargs_ceil 1 def
/_min { dup AssertArray aload length -1 2 { pop 2 copy OperatorGreater { exch } if pop } for } bind def
/__nargs_min 1 def
/_max { dup AssertArray aload length -1 2 { pop 2 copy OperatorLess { exch } if pop } for } bind def
/__nargs_max 1 def
/_Line { gsave 7 2 roll SetLineStyle 1 index 2 AssertArrayLength dup 2 AssertArrayLength newpath exch aload pop moveto aload pop lineto stroke pop pop grestore none } bind def
/__nargs_Line 7 def
/_Arc { gsave 9 2 roll SetLineStyle 3 index 2 AssertArrayLength 2 index AssertNumber 1 index AssertNumber dup AssertNumber newpath 4 -1 roll aload pop 5 2 roll 2 copy lt { arc } { arcn } ifelse stroke pop pop grestore none } bind def
/__nargs_Arc 9 def
/_Circle { gsave SetLineStyle 1 index 2 AssertArrayLength dup AssertNumber newpath exch aload pop 3 2 roll 0 360 arc stroke grestore none } bind def
/__nargs_Circle 5 def
/_FilledCircle { gsave SetCol 1 index 2 AssertArrayLength dup AssertNumber newpath exch aload pop 3 2 roll 0 360 arc fill grestore none } bind def
/__nargs_FilledCircle 3 def
/_FrameCircle { gsave 6 3 roll SetCol 1 index 2 AssertArrayLength dup AssertNumber newpath 1 index aload pop 2 index 0 360 arc fill 5 2 roll SetLineStyle newpath exch aload pop 3 2 roll 0 360 arc stroke grestore none } bind def
/__nargs_FrameCircle 6 def
/_Rect { gsave SetLineStyle 1 index 2 AssertArrayLength dup 2 AssertArrayLength exch aload pop 3 -1 roll aload pop newpath 3 index 3 index moveto 3 index 1 index lineto 1 index 1 index lineto 1 index 3 index lineto closepath stroke 4 PopN grestore none } bind def
/__nargs_Rect 5 def
/_FilledRect { gsave SetCol 1 index 2 AssertArrayLength dup 2 AssertArrayLength exch aload pop 3 -1 roll aload pop newpath 3 index 3 index moveto 3 index 1 index lineto 1 index 1 index lineto 1 index 3 index lineto closepath fill 4 PopN grestore none } bind def
/__nargs_FilledRect 3 def
/_FrameRect { gsave 6 3 roll SetCol 1 index 2 AssertArrayLength dup 2 AssertArrayLength exch aload pop 3 -1 roll aload pop newpath 3 index 3 index moveto 3 index 1 index lineto 1 index 1 index lineto 1 index 3 index lineto closepath fill 7 -3 roll SetLineStyle newpath 3 index 3 index moveto 3 index 1 index lineto 1 index 1 index lineto 1 index 3 index lineto closepath stroke 4 PopN grestore none } bind def
/__nargs_FrameRect 6 def
/_Arrow { gsave SetLineStyle 3 index 2 AssertArrayLength 2 index 2 AssertArrayLength 1 index AssertNumber dup AssertNumber 3 index 3 index newpath exch aload pop 2 copy moveto 3 -1 roll aload pop exch 4 -1 roll sub 3 1 roll exch sub 4 index aload pop 3 index 3 index 7 index neg CalcPos lineto stroke 4 index aload pop 6 2 roll 4 2 roll ArrowHeadFilled pop pop grestore none } bind def
/__nargs_Arrow 7 def
/_Text { gsave dup IsNumber { dup } { fontsize } ifelse 0.7 mul 8 1 roll SetFontFaceAndSize dup AssertNumber 5 -1 roll aload pop translate rotate SetCol exch dup IsString not { 256 string cvs } if exch dup (left) eq { pop 0.0 2 index -2.0 div moveto show } { dup (center) eq { pop dup stringwidth pop 2.0 div neg 2 index -2.0 div moveto show } { dup (right) eq { pop dup stringwidth pop neg 2 index -2.0 div moveto show } { ([Text] invalid alignment constant) ERROR } ifelse } ifelse } ifelse pop grestore none } bind def
/__nargs_Text 7 def
/_PolyLine { gsave pop pop SetLineStyle dup AssertArray CreateLineSegments stroke grestore none } bind def
/__nargs_PolyLine 6 def
/_Polygon { gsave SetLineStyle dup AssertArray CreateLineSegments closepath stroke grestore none } bind def
/__nargs_Polygon 4 def
/_FilledPolygon { gsave SetCol dup AssertArray CreateLineSegments closepath fill grestore none } bind def
/__nargs_FilledPolygon 2 def
/_FramePolygon { gsave 4 -1 roll SetCol 3 index dup AssertArray CreateLineSegments closepath fill SetLineStyle CreateLineSegments closepath stroke grestore none } bind def
/__nargs_FramePolygon 5 def
/_Curve { gsave pop pop SetLineStyle dup AssertArray false CreateCurve stroke grestore none } bind def
/__nargs_Curve 6 def
/_ClosedCurve { gsave SetLineStyle dup AssertArray true CreateCurve stroke grestore none } bind def
/__nargs_ClosedCurve 4 def
/_FilledCurve { gsave SetCol dup AssertArray true CreateCurve fill grestore none } bind def
/__nargs_FilledCurve 2 def
/_FrameCurve { gsave 4 -1 roll SetCol 3 index dup AssertArray true CreateCurve fill SetLineStyle true CreateCurve stroke grestore none } bind def
/__nargs_FrameCurve 5 def
/_TCurve { gsave pop pop SetLineStyle dup AssertArray false CurveWithTangents stroke grestore none } bind def
/__nargs_TCurve 6 def
/_ClosedTCurve { gsave SetLineStyle dup AssertArray true CurveWithTangents stroke grestore none } bind def
/__nargs_ClosedTCurve 4 def
/_FilledTCurve { gsave SetCol dup AssertArray true CurveWithTangents fill grestore none } bind def
/__nargs_FilledTCurve 2 def
/_FrameTCurve { gsave 4 -1 roll SetCol 3 index dup AssertArray true CurveWithTangents fill SetLineStyle true CurveWithTangents stroke grestore none } bind def
/__nargs_FrameTCurve 5 def
/_PCurve { gsave pop pop SetLineStyle dup AssertName false PCurve stroke grestore none } bind def
/__nargs_PCurve 6 def
/_ClosedPCurve { gsave SetLineStyle dup AssertName true PCurve stroke grestore none } bind def
/__nargs_ClosedPCurve 4 def
/_FilledPCurve { gsave SetCol dup AssertName true PCurve fill grestore none } bind def
/__nargs_FilledPCurve 2 def
/_FramePCurve { gsave 4 -1 roll SetCol 3 index dup AssertName true PCurve fill SetLineStyle true PCurve stroke grestore none } bind def
/__nargs_FramePCurve 5 def
/_SetPlotCoordinates { dup IsNumber { dup /coord_xunit exch def /coord_yunit exch def } { dup 2 AssertArrayLength aload pop /coord_yunit exch def /coord_xunit exch def } ifelse dup 2 AssertArrayLength aload pop /coord_yoffset exch def /coord_xoffset exch def none } bind def
/__nargs_SetPlotCoordinates 2 def
/_PlotFunction { gsave SetLineStyle /plotfunctionto exch def /plotfunctionfrom exch def /functiontoplot exch def /fplot false PCurve stroke grestore none } bind def
/__nargs_PlotFunction 6 def
/_CoordinateSystem { gsave dup IsNumber { dup } { fontsize } ifelse 0.7 mul 10 1 roll SetFontFaceAndSize SetLineStyle 3 index 4 AssertArrayLength 2 index 4 AssertArrayLength newpath 3 index 0 ArrayElement 0.0 TransformFCoords moveto 3 index 1 ArrayElement 4 index 2 ArrayElement add 0.0 TransformFCoords lineto stroke 3 index 1 ArrayElement 4 index 2 ArrayElement add 0.0 TransformFCoords exch 3 index add exch 1.0 0.0 5 index 5 index ArrowHeadFilled newpath 0.0 3 index 0 ArrayElement TransformFCoords moveto 0.0 3 index 1 ArrayElement 4 index 2 ArrayElement add TransformFCoords lineto stroke 0.0 3 index 1 ArrayElement 4 index 2 ArrayElement add TransformFCoords 3 index add 0.0 1.0 5 index 5 index ArrowHeadFilled pop pop 1 index aload pop pop exch { newpath 0.0 TransformFCoords 2 copy 2.0 sub moveto 2.0 add lineto stroke } for dup aload pop pop exch { newpath 0.0 exch TransformFCoords 2 copy exch 2.0 sub exch moveto exch 2.0 add exch lineto stroke } for 1 index aload pop exch pop exch 3 1 roll 100 mul cvi 3 1 roll 100 mul cvi 3 1 roll 100 mul cvi { 100.0 div dup (       ) cvs ( ) exch ConcatStrings ( ) ConcatStrings dup stringwidth pop 5 index 4 -1 roll newpath 0.0 TransformFCoords 2 copy 2 copy 4.0 sub moveto 4.0 add lineto stroke 4 -1 roll -2.0 div 3 -1 roll add 3 1 roll exch sub 5 sub moveto show } for dup aload pop exch pop exch 3 1 roll 100 mul cvi 3 1 roll 100 mul cvi 3 1 roll 100 mul cvi { 100.0 div dup (       ) cvs dup stringwidth pop 5 index 4 -1 roll newpath 0.0 exch TransformFCoords 2 copy 2 copy exch 4.0 sub exch moveto exch 4.0 add exch lineto stroke exch 4 -1 roll sub 5 sub exch 3 -1 roll 2.0 div sub moveto show } for pop pop pop grestore none } bind def
/__nargs_CoordinateSystem 9 def
/_debug { DEBUG none } bind def
/__nargs_debug 0 def
/bitmap_ox 0 def
/bitmap_oy 0 def
/bitmap_px 1 def
/bitmap_py 1 def
/bitmap_function () def
/bitmap_generator { /theindex 0 def /thestring bitmap_px bitmap_py 3 mul mul string def 0 1 bitmap_py 1 sub { 0 1 bitmap_px 1 sub { bitmap_ox add 1 index bitmap_oy add bitmap_function cvlit cvx exec aload pop thestring theindex 5 -1 roll 255 mul cvi put thestring theindex 1 add 4 -1 roll 255 mul cvi put thestring theindex 2 add 3 -1 roll 255 mul cvi put /theindex theindex 3 add def } for pop } for thestring } bind def
/_Bitmap { /bitmap_function exch store [ 1 index 0 get 3 index 0 get exch div dup /xscale exch def 0.0 0.0 4 index 1 get 6 index 1 get exch div dup /yscale exch def neg 0.0 0.0 ] /thematrix exch def /xpatches 2 index 0 get 16 idiv def /ypatches 2 index 1 get 16 idiv def /bitmap_px 16 store /bitmap_py 16 store xpatches ypatches mul 0 gt { 0 1 ypatches 1 sub { 0 1 xpatches 1 sub { 16 mul dup /bitmap_ox exch store 4 index 0 get xscale mul add 1 index 16 mul dup /bitmap_oy exch store 5 index 1 get yscale mul sub thematrix 4 3 index neg put thematrix 5 2 index neg put bitmap_px bitmap_py 8 thematrix bitmap_generator false 3 colorimage pop pop } for pop } for } if 1 index 0 get 16 mod 0 ne 2 index 1 get 16 mod 0 ne or { 1 index 1 get 16 mod 0 ne xpatches 0 gt and { /bitmap_px 16 store 1 index 1 get 16 mod /bitmap_py exch store 0 1 xpatches 1 sub { 16 mul dup /bitmap_ox exch store 3 index 0 get xscale mul add ypatches 16 mul dup /bitmap_oy exch store 4 index 1 get yscale mul sub thematrix 4 3 index neg put thematrix 5 2 index neg put bitmap_px bitmap_py 8 thematrix bitmap_generator false 3 colorimage pop pop } for } if 1 index 0 get 16 mod 0 ne ypatches 0 gt and { 1 index 0 get 16 mod /bitmap_px exch store /bitmap_py 16 store 0 1 ypatches 1 sub { xpatches 16 mul dup /bitmap_ox exch store 4 index 0 get xscale mul add exch 16 mul dup /bitmap_oy exch store 4 index 1 get yscale mul sub thematrix 4 3 index neg put thematrix 5 2 index neg put bitmap_px bitmap_py 8 thematrix bitmap_generator false 3 colorimage pop pop } for } if 1 index 0 get 16 mod /bitmap_px exch store 1 index 1 get 16 mod /bitmap_py exch store xpatches 16 mul dup /bitmap_ox exch store 3 index 0 get xscale mul add ypatches 16 mul dup /bitmap_oy exch store 4 index 1 get yscale mul sub thematrix 4 3 index neg put thematrix 5 2 index neg put bitmap_px bitmap_py 8 thematrix bitmap_generator false 3 colorimage pop pop } if pop pop pop none } bind def
/__nargs_Bitmap 4 def
/_Translate { aload pop translate none } bind def
/__nargs_Translate 1 def
/_Rotate { 1 index aload pop translate rotate aload pop neg exch neg exch translate none } bind def
/__nargs_Rotate 2 def
/_Scale { 1 index aload pop translate dup IsArray { aload pop } { dup AssertNumber dup } ifelse scale aload pop neg exch neg exch translate none } bind def
/__nargs_Scale 2 def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% generated code
%

/_ff
{
	2 dict begin
	/_t exch def
	/_return none def

	_t
	0
	OperatorEqual
	{
		/_return
		1
		store
	}
	{
		/_return
		_t
		_sin
		_t
		OperatorDivide
		store
	} ifelse 

	_return end
} bind def
/__nargs_ff 1 def

/_f
{
	2 dict begin
	/_t exch def
	/_return none def

	/_t
	_t
	100.0
	OperatorMinus
	10.0
	OperatorDivide
	store
	_t
	0
	OperatorEqual
	{
		/_return
		150
		store
	}
	{
		/_return
		100
		_t
		_sin
		OperatorTimes
		_t
		OperatorDivide
		50
		OperatorPlus
		store
	} ifelse 

	_return end
} bind def
/__nargs_f 1 def

/_p17
{
	2 dict begin
	/_t exch def
	/_return none def

	/_return
	0.0
	store
	/_p
	1.0
	def
	/_j none def
	/_j
	0
	store
	{
		_j
		17
		OperatorLess
		not { exit } if
		/_return
		_return
		_coeff
		_j
		ArrayElement
		_p
		OperatorTimes
		OperatorPlus
		store
		/_p
		_p
		_t
		OperatorTimes
		store
		/_j
		_j
		1 add
		store
	} loop
	_return
	2
	OperatorGreater
	{
		/_return
		2
		store
	}
	{
		_return
		2
		OperatorNegate
		OperatorLess
		{
			/_return
			2
			OperatorNegate
			store
		} if
	} ifelse 

	_return end
} bind def
/__nargs_p17 1 def

[
30
OperatorNegate
10
OperatorNegate
]
[
230
180
]
0.9
_FilledRect
pop
/_i none def
/_x
[
0.0
20.0
30.0
50.0
65.0
85.0
90.0
105.0
112.5
120.0
133.0
137.5
140.0
155.0
160.0
175.0
186.0
]
def
/_y
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
def
/_noise
[
4
OperatorNegate
8
5
2
4
OperatorNegate
6
7
OperatorNegate
1
OperatorNegate
2
6
OperatorNegate
0
9
3
OperatorNegate
8
OperatorNegate
2
OperatorNegate
5
1
OperatorNegate
]
def
/_i
0
store
{
	_i
	_x
	_length
	OperatorLess
	not { exit } if
	_y
	_i
	2 copy AssertArrayIndex
	_x
	_i
	ArrayElement
	_f
	_noise
	_i
	ArrayElement
	OperatorPlus
	put
	/_i
	_i
	1 add
	store
} loop
[
100
50
]
[
10
100
]
_SetPlotCoordinates
pop
[
10
OperatorNegate
10
1
5
]
[
0.5
OperatorNegate
1
0.1
0.5
]
10
5
(solid)
1
0
none
none
_CoordinateSystem
pop
/_ff
10
OperatorNegate
10
(dashed)
1
[
0
0.5
0
]
_PlotFunction
pop
/_i
0
store
{
	_i
	_x
	_length
	OperatorLess
	not { exit } if
	[
	_x
	_i
	ArrayElement
	_y
	_i
	ArrayElement
	]
	3
	[
	1
	0
	0
	]
	_FilledCircle
	pop
	/_i
	_i
	1 add
	store
} loop
/_coeff
[
7.3001e-01
5.9838e-02
2.8184e-01
9.5968e-02
2.1240e-01
OperatorNegate
7.0841e-02
OperatorNegate
5.2606e-02
9.5897e-03
5.5384e-03
OperatorNegate
4.6845e-04
OperatorNegate
2.6945e-04
9.3603e-06
6.3547e-06
OperatorNegate
7.0505e-08
OperatorNegate
7.0517e-08
9.9079e-11
2.9376e-10
OperatorNegate
]
def
/_p17
10.1
OperatorNegate
10.1
(solid)
1
[
0
0.5
0
]
_PlotFunction
pop

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

} stopped pop
showpage
end
grestore
