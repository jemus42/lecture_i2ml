% Introduction to Machine Learning
% Day 3

% Set style/preamble.Rnw as parent.
<<set-parent, include = FALSE>>=
knitr::set_parent("../style/preamble.Rnw")
@

% Load all R packages and set up knitr
<<setup, child="../style/setup.Rnw", include = FALSE>>=
@

\lecturechapter{Code demo for splines}
\lecture{intro to ML}

\begin{vbframe}{Splines}

\begin{itemize}
\item One common idea in machine learning consists in transforming the features of interest.
\item Here we will take a look on so-called splines.
\item With splines we can model arbitrarily well smooth functional relationships.
\item This means that we will represent the features as projections on a splines basis.
\item We can treat this projected features like we did for the linear model and by using the empirical risk minimization we can get then an estimation for the regression coefficients, which determine the shape of the spline.
\end{itemize}

\framebreak

\begin{itemize}
\item One of the most common used spline basis is the so-called B-spline basis, which consists of locally defined polynomials.
\item To use splines firstly we have to fill our domain with knots $t_1,\dots,t_m$, which will serve as supporting points for the spline.
\item For example we can use 5 equidistant knots with polynomials of degree 1 (\textbf{left}) or of degree 2 (\textbf{right}):
\end{itemize}

<<eval= TRUE, echo = FALSE, fig.height=3>>=
library(splines)
library(gridExtra)

bs_plot <- function(poly_deg = 1) {
  num_data = 1000
  num_knots = 9

  min = -2
  max = 2
  x = seq(min, max, length.out = num_data)
  knots = seq(min, max, length.out = num_knots)

  bbasis = bs(x, knots = knots, degree = poly_deg,)

  plot_df = melt(data.frame(cbind(bbasis, x)), id = "x")

  ggplot(plot_df, aes(x = x, color = variable)) +
    geom_line(aes(y = value)) + xlim(-1, 1) +
    ylab("y") + theme(legend.position = "none") + scale_color_brewer(palette ="Dark2")
}

plot_poly1 = bs_plot(poly_deg = 1)
plot_poly2 = bs_plot(poly_deg = 2)

grid.arrange(plot_poly1, plot_poly2, ncol=2)
@

\framebreak
<<bspline, eval= TRUE, echo = TRUE, tidy=TRUE, tidy.opts=list(width.cutoff=58)>>=
### Example
plot_func <- function(pol_deg, num_knots) {
  sy = summary(BostonHousing2$rm)
  all_knots = seq(sy[["Min."]], sy[["Max."]], length.out = num_knots)
  endKnots = all_knots[c(1, num_knots)]
  innerKnots =  all_knots[2:(num_knots - 1)]
  bspline = bs(BostonHousing2$rm, knots = innerKnots,degree = pol_deg,Boundary.knots = endKnots
  )
  bspline_df =  data.frame(bspline)
  bspline_df$medv = BostonHousing2$medv
  # Estimate a linear model for transformed features
  lm_bs = lm("medv ~ .", data = bspline_df)
  bspline_df$rm = BostonHousing2$rm
  plot_df = data.frame(x = seq(sy[["Min."]], sy[["Max."]], length.out = 200))
  plot_df$y = cbind(1.0, bs(plot_df$x, knots = innerKnots, degree = pol_deg,
      Boundary.knots = endKnots
    )
  ) %*%
    lm_bs$coefficients
  ggplot(BostonHousing2, aes(x = rm)) +
    geom_point(aes(y = medv), alpha = 0.3) +
    geom_line(data = plot_df, aes(x = x, y = y), color="red") +
    labs(title = paste(as.character(num_knots), "knots"),
         x = "Average number of rooms",
         y = "Median value")
}
@
\framebreak
Cubic splines with varying number of knots
<<spline_plot, eval= TRUE, echo = TRUE, tidy=TRUE, tidy.opts=list(width.cutoff=58)>>=
data(BostonHousing2)
library(splines)

pol_deg = 3
p1 = plot_func(pol_deg, 3)
p2 = plot_func(pol_deg, 5)
p3 = plot_func(pol_deg, 10)
p4 = plot_func(pol_deg, 20)

grid.arrange(p1, p2, p3, p4, ncol=2, nrow=2)
@

\framebreak

\begin{itemize}
\item We only computed a simple linear model, but instead of the orginal feature we used its transformed features.
\item We observe that the quality of the fit depends on the number of knots that we choose.
\item For higher number of knots a phenomenon called overfitting, where the model does not generalize well, can be seen which will be discussed in chapter 3.
\end{itemize}

\end{vbframe}
\endlecture
