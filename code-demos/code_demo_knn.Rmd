---
output: pdf_document
params:
  set_title: Code demo for KNN
---

```{r, child = "../style/preamble_code_demos.Rmd", include = FALSE}

```

```{r, child = "../style/setup.Rmd", include = FALSE}

```  

# Code demo for KNN

## Recap the functioning of $k$-NN

- For each point to be predicted, calculate the distance or dissimilarity to all training data points using any distance measure
- Most common distance measures:
  - Metric feature vectors in $\mathbb R^p$:
      - Euclidean distance: $d_2(a, b) = \sqrt{(a - b)^T(a - b)} = \sqrt{(a_1 - b_1)^2 + \dots + (a_p - b_p)^2}$
      - Manhattan distance: $d_1(a, b) = |a_1 - b_1| + \dots + |a_p - b_p|$
      - [Mahalanobis distance](https://en.wikipedia.org/wiki/Mahalanobis_distance): $d_{\text{Mahalanobis}}(a, b) = \sqrt{(a - b)^T S^{-1}(a - b)}$, where $S$ is the [covariance matrix](https://en.wikipedia.org/wiki/Covariance_matrix) of the features.
  - Categorical feature vectors:
      - [Simple Matching Coefficient](https://en.wikipedia.org/wiki/Simple_matching_coefficient): relative proportion of matching attributes
      - [Jaccard Coefficient](https://en.wikipedia.org/wiki/Jaccard_index#Similarity_of_asymmetric_binary_attributes): Similar to above, but discards entries where neither $a$ nor $b$ have a value of 1.
  - Mixed feature vectors:
      - [Gower distance](https://stats.stackexchange.com/a/15313)
- Select the $k$ nearest neighbors to the point and use the most frequently occurring class in this neighborhood as prediction

## Example

We look at the `iris` data set which consists of only numeric features and a categorical output. In the lecture we learnt that for $k$-NN the *representation* is the training data. Let's say our training data is only 50 percent of our original data.

```{r knn-import-iris}
data(iris)

set.seed(2)

trainRelativeSize <- 0.5
trainIndices <- sample(
  x = seq(1, nrow(iris), by = 1), size =
    ceiling(trainRelativeSize * nrow(iris)), replace = FALSE
)
irisTrain <- iris[ trainIndices, ]
str(iris)
```

Imagine five data points:

```{r knn-subset-iris}
dataSnippet <- iris[c(1, 2, 3, 55, 110), -4]
levels(dataSnippet[, "Species"]) <- c(levels(dataSnippet[, "Species"]), "???")
dataSnippet[3, "Species"] <- "???"
print(dataSnippet)
```

Which class would you select as prediction for the unknown observation?

```{r knn-plot-iris, echo=TRUE}
library(ggplot2)
library(gridExtra)

proj1 <- ggplot(
  dataSnippet, 
  aes(
    x = Sepal.Length,
    y = Sepal.Width,
    color = Species,
  )) +
  geom_point(size = 3)
proj2 <- ggplot(
  dataSnippet, 
  aes(
    x = Sepal.Length,
    y = Petal.Length,
    color = Species
  )) +
  geom_point(size = 3)
proj3 <- ggplot(
  dataSnippet, 
  aes(
    x = Sepal.Width,
    y = Petal.Length,
    color = Species
  )) +
  geom_point(size = 3)

grid.arrange(proj1, proj2, proj3, ncol = 2, nrow = 2)
```

---------------------------

## Implementation

The function takes a vector of training data class labels, 
the training data, the data on which we want to perform knn classification as well as the $k$ parameter, and the distance measure we want to use. 
We also include the option to standardize the features. (Why is that important?)

```{r knn-knn-def} 
distance_euclidean <- function(a, b) {
  sqrt(sum((a - b)^2))
}

# function to classify data with knn
getKNN <- function(trainLabels, trainData, toClassifyData, k,
                   distance = distance_euclidean, standardize = FALSE) {
  # TODO: for a real implementation, we would need to add input checks here to
  #       make our implicit assumptions about the inputs explicit:
  #  trainLabels: vector with no NAs, same length as rows of trainData
  #  trainData: data.frame or matrix without NAs, same columns as toClassifyData
  #  toClassifyData: data.frame or matrix without NAs
  #  k: single positive integer, at most number of rows of trainData
  #  distance: a function taking two arguments (hard to check beyond that...)

  numPreds <- nrow(toClassifyData)
  pred <- rep(as.character(NA), numPreds)

  # transform data to speedup computation
  trainData <- data.matrix(trainData)
  toClassifyData <- data.matrix(toClassifyData)

  # standardize the feature vectors if desired
  if (standardize == TRUE) {
    trainData <- scale(trainData)
    toClassifyData <- scale(
      toClassifyData,
      center = attr(trainData, "scaled:center"),
      scale = attr(trainData, "scaled:scale")
    )
  }
  for (i in seq_len(numPreds)) {
    # compute distance to all training data points
    distanceToTrain <- apply(
      trainData, 
      MARGIN = 1,
      FUN = function(x) distance(x, toClassifyData[i, ])
    )
    # extract row indices of k nearest ones
    nearestNeighbors <- order(distanceToTrain)[1:k]
    # compute frequencies of classes in neighborhood
    classFrequency <- table(trainLabels[nearestNeighbors])
    mostFrequentClasses <-
      names(classFrequency)[classFrequency == max(classFrequency)]
    # random tie breaking if more than 1 class has maximal frequency
    pred[i] <- sample(mostFrequentClasses, 1)
  }

  list(prediction = pred, levels = levels(trainLabels))
}
```
Let's check how well the training data is classified with our implementation for $k = 5$:
```{r knn-run}
toCheckResult <- getKNN(
  trainLabels = irisTrain$Species,
  trainData = irisTrain[, 1:4],
  toClassifyData = irisTrain[, 1:4],
  k = 5, standardize = FALSE
)
table(actual = irisTrain$Species, predicted = toCheckResult$prediction)

correct <- (irisTrain$Species == toCheckResult$prediction)
print(paste(
  100 * round(mean(correct), 4),
  "% correctly classified"
))
```

Since the model above is based on a $p = 4$ dimensional feature vector, it's hard to visualize what $k$-NN actually does. 

To get a better understanding how $k$-NN works, at least for just two features, we can write a simple plot function, where we divide the two dimensional feature space into a grid and color all grid cells according to the class that $k$-NN would assign to their midpoint based on a given training data set. Data points that are misclassified are shown in white, the others in gray.
```{r knn-plot2dknn-def}  
# function for simple k-NN with two features to visualize class boundaries
# X1 and X2 are the names of the two features to use. 
plot2DKNN <- function(trainLabels, trainData, k, X1, X2,
                      distance = distance_euclidean, standardize = FALSE,
                      # by default, we "predict" the class of the training data:_
                      toClassifyLabels = trainLabels,
                      toClassifyData = trainData,
                      lengthX1 = 100, lengthX2 = 100) {
  gridX1 <- seq(
    min(toClassifyData[, X1]),
    max(toClassifyData[, X1]),
    length.out = lengthX1
  )
  gridX2 <- seq(
    min(toClassifyData[, X2]),
    max(toClassifyData[, X2]),
    length.out = lengthX2
  )

  # compute grid coordinates with cartesian product
  gridData <- expand.grid(gridX1, gridX2)
  names(gridData) <- c(X1, X2)
  
  # assign grid cells to classes based on k-NN rule:
  gridResult <- getKNN(
    trainLabels = trainLabels,
    trainData = trainData[, c(X1, X2)],
    toClassifyData = gridData,
    k = k, distance = distance, standardize = standardize
  )
  gridData$prediction <- gridResult$prediction
  
  toCheckResult <- getKNN(
    trainLabels = trainLabels,
    trainData = trainData[, c(X1, X2)],
    toClassifyData = toClassifyData[, c(X1, X2)],
    k = k, distance = distance, standardize = standardize
  )
  toClassifyData$class <- toClassifyLabels
  toClassifyData$correct <- (toCheckResult$prediction == toClassifyLabels)


  ggplot() +
    geom_raster(
      data = gridData, 
      aes_string(x = X1, y = X2, fill = "prediction"), 
      alpha = .8
    ) +
    geom_point(
      data = toClassifyData, 
      aes_string(x = X1, y = X2, shape = "class", color = "correct"),
      alpha = .8
    ) +
    scale_color_manual(
      values = c("TRUE" = "darkgray", "FALSE" = "white"), 
      guide = FALSE
    ) +
    labs(
      fill = "Class", shape = "Class",
      title = paste0(
        "k = ", as.character(k), ": ",
        100 * round(mean(toClassifyData$correct), 4),
        "% correctly classified"
      )
    )
}
```

Let's plot the classification we did before, but now with only two features:

```{r knn-plot2dknn-1} 
plot2DKNN(
  trainLabels = irisTrain$Species,
  trainData = irisTrain[, -5],
  k = 3,
  X1 = "Petal.Width", X2 = "Sepal.Length"
)
```

Visualize results for different $k$:
```{r knn-plot2dknn-2}   
kValues <- c(1, 5, 15, 43)
ggplotList <- lapply(
  kValues,
  function(k) {
    plot2DKNN(
      trainLabels = irisTrain$Species,
      trainData = irisTrain[, -5],
      k = k,
      X1 = "Petal.Width", X2 = "Sepal.Length"
    )
  }
)
do.call(grid.arrange, ggplotList)
```
For $k=1$ we only get a single error (see center of the plane) since there are only two observations with identical features, but different labels, in our training data set (and that case is the only way we could ever make an error for $k = 1$).

So why should we use a $k \neq 1$?

Let's look how we perform when we apply our $k$-NN classification rules to the entries in the `iris` data set which were not used for training:
```{r knn-plot2dknn-3}    
# new, previously unseen data to classify:
irisToCheck <- iris[-trainIndices, ]
kValues <- c(1, 5, 15, 43)
ggplotList <- lapply(
  kValues,
  function(k) {
    plot2DKNN(
      trainLabels = irisTrain$Species,
      trainData = irisTrain[, -5],
      k = k,
      toClassifyLabels = irisToCheck$Species,
      toClassifyData = irisToCheck[, -5],
      X1 = "Petal.Width", 
      X2 = "Sepal.Length"
    )
  }
)
do.call(grid.arrange, ggplotList)
```
Now we observe that, on data we didn't use as training data, the value of $k$ for which we get the best classification accuracy seems to be higher than 1.

Models very often perform much better on the training data than on other data sets, this
is called **overfitting** and will be discussed in details in the chapters on performance evaluation and tuning. 

## Standardization

We included the option to standardize features by subtracting their mean and dividing by their standard deviation so that the value of the $i$-th value of the $j$-th feature is:

$$ 
x^{(i)}_{j,\text{standardized}} = \frac{x^{(i)}_{j} - \overline{x}_j}{\sqrt{\frac{1}{n-1}\sum^n_{i=1}\left(x^{(i)}_{j} - \overline{x}_j\right)^2}}.
$$

This makes sense if features are on totally different scales (e.g. millimeter vs. kilometer) or even in completely different units (e.g. kilogram vs Euro). In such cases we would compare apples with oranges and the distances would be weighted unequally. After standardization, all features are unitless and the numbers simply represent how many standard deviations an observation of a feature is above or below its mean. (Can you figure out under which conditions the Mahalaobis distance and the Euclidean distance of the standardized features are identical?)

Does standardization improve performance for the `iris` data?

```{r knn-plot2dknn-4}  
kValues <- c(1, 5, 15, 43)
ggplotList <- lapply(
  kValues,
  function(k) {
    plot2DKNN(
      trainLabels = irisTrain$Species,
      trainData = irisTrain[, -5],
      k = k,
      ##
      standardize = TRUE,
      ##
      toClassifyLabels = irisToCheck$Species,
      toClassifyData = irisToCheck[, -5],
      X1 = "Petal.Width", 
      X2 = "Sepal.Length"
    )
  }
)
do.call(grid.arrange, ggplotList)
```

### `mlr` implementation

The `mlr` package offers a unified interface to many different machine learning algorithms making complicated, inefficient and error-prone implementations as above unnecessary.  
Check the [tutorial](https://mlr-org.github.io/mlr-tutorial/devel/html/learner/index.html#modifying-a-learner) and the [list of integrated learners](https://mlr-org.github.io/mlr-tutorial/release/html/integrated_learners/). It uses a simple syntax, as used below:

```{r knn-mlr-1}
library(mlr)
# define task
irisTask <- makeClassifTask(data = irisTrain, target = "Species")
# define learner and check possible models on mlr homepage
irisLearner <- makeLearner("classif.kknn", k = 5)
# check available parameter settings
getParamSet(irisLearner)
```

```{r knn-mlr-2}
# train the model
irisModel <- train(learner = irisLearner, task = irisTask)
# predict on test data
irisPred <- predict(irisModel, newdata = irisToCheck[, -5])
# check "confusion" matrix
print(table(actual = irisToCheck$Species, predicted = irisPred$data$response))

round(mean(irisPred$data$response == irisToCheck$Species), 5)
```
